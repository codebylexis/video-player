import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import * as XLSX from "xlsx";
import { LoggedEvent } from "@/components/ManualEventLogger";
import { SurgicalPhase, InstrumentUsage } from "@/components/ProcedureTimeline";
import { CaseDetails } from "@/components/ProcedureDetailsDialog";
import { ResearchQA, generateResearchQA } from "@/lib/research-engine";

interface ReportData {
  caseDetails: CaseDetails;
  phases: SurgicalPhase[];
  instruments: InstrumentUsage[];
  events: LoggedEvent[];
  annotations: any[];
  snapshots: string[];
  insights?: ResearchQA[]; // Optional, if not provided we generate them
}

export const generateReport = async (data: ReportData) => {
  const zip = new JSZip();
  
  // Ensure insights exist
  const insights = data.insights || generateResearchQA(data.phases, data.instruments, data.events);

  // 1. Generate PDF Report
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  
  // Add Logo (Top Right)
  // Assuming a standard logo placeholder or using the app's logo if available as a base64 string
  // For this template, we'll use a text-based logo representation or a placeholder shape if no image is provided
  doc.setFillColor(52, 211, 153); // Emerald-400 (App Theme Color)
  doc.circle(pageWidth - 30, 25, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(14);
  doc.text("SAS", pageWidth - 36, 27); // Surgical Analysis Suite Initials

  // Header
  doc.setFontSize(22);
  doc.setTextColor(40, 40, 40);
  doc.text("Surgical Analysis Report", 20, 20);
  
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 30);
  
  // Case Details
  doc.setDrawColor(200, 200, 200);
  doc.line(20, 35, pageWidth - 20, 35);
  
  doc.setFontSize(14);
  doc.setTextColor(0, 0, 0);
  doc.text("Case Information", 20, 45);
  
  const details = [
    ["Case ID", data.caseDetails.id],
    ["Surgeon", data.caseDetails.surgeon],
    ["Procedure", data.caseDetails.procedure],
    ["Date", data.caseDetails.date],
    ["Notes", data.caseDetails.notes || "N/A"]
  ];
  
  autoTable(doc, {
    startY: 50,
    head: [],
    body: details,
    theme: 'plain',
    styles: { fontSize: 10, cellPadding: 2 },
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: 40 } }
  });

  // Insights Summary
  let yPos = (doc as any).lastAutoTable.finalY + 15;
  doc.setFontSize(14);
  doc.text("Key Insights & Analysis", 20, yPos);
  
  const insightRows = insights.map(qa => [qa.category, qa.question, qa.answer]);
  
  autoTable(doc, {
    startY: yPos + 5,
    head: [['Category', 'Question', 'Analysis']],
    body: insightRows,
    theme: 'grid',
    headStyles: { fillColor: [41, 128, 185], textColor: 255 },
    styles: { fontSize: 9, cellPadding: 3 },
    columnStyles: { 0: { cellWidth: 30 }, 1: { cellWidth: 60 } }
  });

  // Event Log
  doc.addPage();
  doc.setFontSize(14);
  doc.text("Procedure Event Log", 20, 20);
  
  const eventRows = data.events.map(e => [
    new Date(e.startTime * 1000).toISOString().substr(11, 8),
    e.label,
    e.type,
    e.category,
    `${Math.floor((e.endTime - e.startTime))}s`
  ]);
  
  autoTable(doc, {
    startY: 25,
    head: [['Time', 'Event', 'Type', 'Phase', 'Duration']],
    body: eventRows,
    theme: 'striped',
    headStyles: { fillColor: [52, 73, 94] }
  });

  // Disclaimer
  const pageCount = doc.getNumberOfPages();
  for(let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text("CONFIDENTIAL - PHI PROTECTED - FOR AUTHORIZED USE ONLY", pageWidth / 2, doc.internal.pageSize.height - 10, { align: "center" });
  }

  const pdfBlob = doc.output("blob");
  zip.file("Report.pdf", pdfBlob);

  // 2. Generate Advanced Excel Export
  const wb = XLSX.utils.book_new();

  // Sheet 1: Summary Dashboard
  const summaryData = [
    ["Surgical Analysis Suite - Executive Summary"],
    [""],
    ["Case ID", data.caseDetails.id],
    ["Surgeon", data.caseDetails.surgeon],
    ["Procedure", data.caseDetails.procedure],
    ["Date", data.caseDetails.date],
    [""],
    ["Total Duration", `${Math.floor(data.phases.reduce((acc, p) => acc + (p.endTime - p.startTime), 0) / 60)} min`],
    ["Total Events", data.events.length],
    ["Complications", data.events.filter(e => e.type === "complication").length],
    [""],
    ["Generated By", "Surgical Analysis Suite AI"]
  ];
  const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(wb, wsSummary, "Summary");

  // Sheet 2: Detailed Event Log
  const eventLogData = data.events.map(e => ({
    "Time (HH:MM:SS)": new Date(e.startTime * 1000).toISOString().substr(11, 8),
    "Event Label": e.label,
    "Type": e.type,
    "Phase": e.category,
    "Duration (s)": e.endTime - e.startTime,
    "Start Timestamp": e.startTime,
    "End Timestamp": e.endTime
  }));
  const wsEvents = XLSX.utils.json_to_sheet(eventLogData);
  XLSX.utils.book_append_sheet(wb, wsEvents, "Event Log");

  // Sheet 3: Insights & Q&A
  const insightsData = insights.map(qa => ({
    "Category": qa.category,
    "Question": qa.question,
    "Analysis/Answer": qa.answer,
    "Related Timestamp": qa.timestamp ? new Date(qa.timestamp * 1000).toISOString().substr(11, 8) : "N/A",
    "Metrics": qa.metrics.map(m => `${m.label}: ${m.value}${m.unit || ''}`).join(", ")
  }));
  const wsInsights = XLSX.utils.json_to_sheet(insightsData);
  XLSX.utils.book_append_sheet(wb, wsInsights, "Insights");

  // Sheet 4: Instrument Analytics
  const instrumentStats: Record<string, { count: number, totalDuration: number, passes: number }> = {};
  data.instruments.forEach(inst => {
    if (!instrumentStats[inst.label]) {
      instrumentStats[inst.label] = { count: 0, totalDuration: 0, passes: 0 };
    }
    instrumentStats[inst.label].count++;
    instrumentStats[inst.label].totalDuration += (inst.endTime - inst.startTime);
    instrumentStats[inst.label].passes++; // Assuming each entry is a pass
  });

  const totalProcTime = data.phases.reduce((acc, p) => acc + (p.endTime - p.startTime), 0) || 1;

  const instrumentData = Object.entries(instrumentStats).map(([name, stats]) => ({
    "Instrument": name,
    "Total Usage Time (s)": stats.totalDuration,
    "Usage % of Procedure": `${((stats.totalDuration / totalProcTime) * 100).toFixed(2)}%`,
    "Passes / Activations": stats.passes,
    "Avg Duration per Pass (s)": (stats.totalDuration / stats.passes).toFixed(1)
  }));
  const wsInstruments = XLSX.utils.json_to_sheet(instrumentData);
  XLSX.utils.book_append_sheet(wb, wsInstruments, "Instrument Analytics");

  // Sheet 5: Complications
  const complicationsData = data.events
    .filter(e => e.type === "complication")
    .map(e => ({
      "Time": new Date(e.startTime * 1000).toISOString().substr(11, 8),
      "Description": e.label,
      "Phase": e.category,
      "Duration Impact": `${e.endTime - e.startTime}s`
    }));
  
  if (complicationsData.length > 0) {
    const wsComplications = XLSX.utils.json_to_sheet(complicationsData);
    XLSX.utils.book_append_sheet(wb, wsComplications, "Complications");
  } else {
    const wsComplications = XLSX.utils.aoa_to_sheet([["No complications recorded."]]);
    XLSX.utils.book_append_sheet(wb, wsComplications, "Complications");
  }

  // Generate Excel Buffer
  const excelBuffer = XLSX.write(wb, { bookType: "xlsx", type: "array" });
  zip.file("Surgical_Data_Analysis.xlsx", excelBuffer);

  // 3. Snapshots Folder
  const imgFolder = zip.folder("Snapshots");
  if (imgFolder) {
    data.snapshots.forEach((url, index) => {
      // Convert data URL to blob (mock implementation for now as we don't have real blobs in this context easily without fetch)
      // In a real app, we'd fetch the blob. Here we assume data URI or just save a text file with the link if it's remote.
      if (url.startsWith("data:")) {
        const data = url.split(",")[1];
        imgFolder.file(`snapshot_${index + 1}.png`, data, { base64: true });
      } else {
        // For remote URLs, we can't easily download them in client-side JS without CORS, 
        // so we'll create a reference file.
        imgFolder.file(`snapshot_${index + 1}_link.txt`, url);
      }
    });
  }

  // 4. Generate and Save Zip
  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, `Surgical_Report_${data.caseDetails.id}.zip`);
};
